[{"title":"goland ssh连接orbstack虚拟机鉴权失败问题解决,报错\"Invalid credentials\"","url":"/2025/10/01/golang-ssh%E8%BF%9E%E6%8E%A5orbstack%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%89%B4%E6%9D%83%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","content":"新近入手macbook,想体验下在macOS下开发，刚好接触到了orbtack,按照官网wiki成功用vscode连接到了创建的虚拟机，但是使用goland连接时出现问题，这里简单记录下报错和解决方案\n\n现象按照官官网https://docs.orbstack.dev/machines/ssh指示，连接到orbstack创建的虚拟机似乎并不困难，但是我在使用goland连接时出现报错，goland配置和报错如图：\n原因配置中我有两个错误\n\n用户不是自己虚拟机登陆用户refra1n，而是default，且为了区分不同虚拟机，应当是default@$我的虚拟机名\n密钥我使用的虚拟机上～&#x2F;.ssh&#x2F;中的密钥，实际上应该使用MacBook上～&#x2F;.orbstack&#x2F;ssh中的密钥\n\n解决按照如下配置成功连接。注意我把～&#x2F;.orbstack&#x2F;ssh里的key拷贝到了其他路径，原因是Macos下的隐藏路径对goland不可见另外如果想要支持其他用户登陆的话，改写下～&#x2F;.orbstack&#x2F;ssh&#x2F;config中的User字段即可\n","categories":["未分类"],"tags":["untage"]},{"title":"go context 使用与理解","url":"/2025/10/02/go-context-%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%90%86%E8%A7%A3/","content":"在go GMP模型中，开发者感知最多的是G,也就是goroutine,而G之间存在两种常见关系：派生(go rountineFunc())与远程调用(rpc)。如何在这两种G之间传递上下文信息——使用context。context分为emptyCtx(background，todo)，timerCtx，cancelCtx，valueCtx\n\ncancelCtx使用示例cancelCtx用于中G之间同步取消消息，可见于：\n\n父子G间的上下文，例如父G call出子G后，等待系统信号，如果系统有kill或者ctrl+c信号，需要让子G作收尾动作，例如发送未发送完的消息，清理相关资源等\n\npackage mainimport (\t&quot;context&quot;\t&quot;fmt&quot;\t&quot;os&quot;\t&quot;os/signal&quot;\t&quot;runtime&quot;\t&quot;strconv&quot;\t&quot;strings&quot;\t&quot;sync&quot;\t&quot;syscall&quot;\t&quot;time&quot;)func getGoroutineId() int &#123;\tvar buf [64]byte\tn := runtime.Stack(buf[:], false)\t// 提取 goroutine ID\tfield := strings.Fields(strings.TrimPrefix(string(buf[:n]), &quot;goroutine &quot;))[0]\tid, _ := strconv.Atoi(field)\treturn id&#125;func gWork(c context.Context, wg *sync.WaitGroup) &#123;\tdefer wg.Done()\tworker := getGoroutineId()\tn := 0\tfor &#123;\t\tselect &#123;\t\tdefault:\t\t\ttime.Sleep(1 * time.Second)\t\t\tfmt.Printf(&quot;G%d doing regular work %d\\n&quot;, worker, n)\t\t\tn += 1\t\tcase &lt;-c.Done():\t\t\tfmt.Printf(&quot;recive stop signal,reason:%s\\n&quot;, c.Err().Error())\t\t\tfmt.Printf(&quot;G%d now doing ending work...,and done!\\n&quot;, worker)\t\t\treturn\t\t&#125;\t&#125;&#125;func main() &#123;\tcancelCtx1, cancelFunc1 := context.WithCancel(context.Background())\tdefer cancelFunc1() // 防止中途出错，没走到接收同志信号\tcancelCtx2, cancelFunc2 := context.WithCancel(context.Background())\tdefer cancelFunc2() // 防止中途出错，没走到接收同志信号\tvar waitG sync.WaitGroup\tgo gWork(cancelCtx1, &amp;waitG)\tgo gWork(cancelCtx2, &amp;waitG)\twaitG.Add(2)\tsignalCh := make(chan os.Signal, 1)\tsignal.Notify(signalCh, syscall.SIGINT, syscall.SIGTERM) // 注册对ctrl和kill的监听\t&lt;-signalCh\tcancelFunc1()\tcancelFunc2()\twaitG.Wait()&#125;\n\n由父子G可以推及链式context，取消父context，整个链路的context都会被cancel\n\npackage mainimport (\t&quot;context&quot;\t&quot;fmt&quot;\t&quot;os&quot;\t&quot;os/signal&quot;\t&quot;runtime&quot;\t&quot;strconv&quot;\t&quot;strings&quot;\t&quot;sync&quot;\t&quot;syscall&quot;\t&quot;time&quot;)func getGoroutineId() int &#123;\tvar buf [64]byte\tn := runtime.Stack(buf[:], false)\t// 提取 goroutine ID\tfield := strings.Fields(strings.TrimPrefix(string(buf[:n]), &quot;goroutine &quot;))[0]\tid, _ := strconv.Atoi(field)\treturn id&#125;func gWork2(c context.Context, wg *sync.WaitGroup) &#123;\tdefer wg.Done()\tn := 0\tworker := getGoroutineId()\tfor &#123;\t\tselect &#123;\t\tdefault:\t\t\ttime.Sleep(1 * time.Second)\t\t\tfmt.Printf(&quot;G%d doing regular work %d in worker2\\n&quot;, worker, n)\t\t\tn += 1\t\tcase &lt;-c.Done():\t\t\tfmt.Printf(&quot;recive stop signal,reason:%s\\n&quot;, c.Err().Error())\t\t\tfmt.Printf(&quot;G%d now doing ending work...,and done!\\n&quot;, worker)\t\t\treturn\t\t&#125;\t&#125;&#125;func gWork(c context.Context, wg *sync.WaitGroup) &#123;\tdefer wg.Done()\tworker := getGoroutineId()\tn := 0\tc2, _ := context.WithCancel(c)\twg.Add(1)\tgo gWork2(c2, wg)\tfor &#123;\t\tselect &#123;\t\tdefault:\t\t\ttime.Sleep(1 * time.Second)\t\t\tfmt.Printf(&quot;G%d doing regular work %d in worker1\\n&quot;, worker, n)\t\t\tn += 1\t\tcase &lt;-c.Done():\t\t\tfmt.Printf(&quot;recive stop signal,reason:%s\\n&quot;, c.Err().Error())\t\t\tfmt.Printf(&quot;G%d now doing ending work...,and done!\\n&quot;, worker)\t\t\treturn\t\t&#125;\t&#125;&#125;func main() &#123;\tcancelCtx1, cancelFunc1 := context.WithCancel(context.Background())\tdefer cancelFunc1() // 防止中途出错，没走到接收同志信号\tvar waitG sync.WaitGroup\tgo gWork(cancelCtx1, &amp;waitG)\twaitG.Add(1)\tsignalCh := make(chan os.Signal, 1)\tsignal.Notify(signalCh, syscall.SIGINT, syscall.SIGTERM) // 注册对ctrl和kill的监听\t&lt;-signalCh\tcancelFunc1()\twaitG.Wait()&#125;\n两个例子可见G需要对传入的context进行处理，主要是监听取消消息之后采取什么动作，依业务而定\ntimerCtx使用用例\n不同G之间的超时调用\n\npackage mainimport (\t&quot;context&quot;\t&quot;fmt&quot;\t&quot;runtime&quot;\t&quot;strconv&quot;\t&quot;strings&quot;\t&quot;sync&quot;\t&quot;time&quot;)func getGoroutineId() int &#123;\tvar buf [64]byte\tn := runtime.Stack(buf[:], false)\t// 提取 goroutine ID\tfield := strings.Fields(strings.TrimPrefix(string(buf[:n]), &quot;goroutine &quot;))[0]\tid, _ := strconv.Atoi(field)\treturn id&#125;func gWork(c context.Context, wg *sync.WaitGroup) &#123;\tdefer wg.Done()\tworker := getGoroutineId()\tn := 0\tfor &#123;\t\tselect &#123;\t\tdefault:\t\t\ttime.Sleep(1 * time.Second)\t\t\tfmt.Printf(&quot;G%d doing regular work %d in worker1\\n&quot;, worker, n)\t\t\tn += 1\t\tcase &lt;-c.Done():\t\t\tfmt.Printf(&quot;recive stop signal,reason:%s\\n&quot;, c.Err().Error())\t\t\tfmt.Printf(&quot;G%d now doing ending work...,and done!\\n&quot;, worker)\t\t\treturn\t\t&#125;\t&#125;&#125;func main() &#123;\tcancelCtx, _ := context.WithCancel(context.Background())\ttimerCtx, cancelFunc := context.WithTimeout(cancelCtx, 10*time.Second)\tdefer cancelFunc() // 防止中途出错，没走到接收同志信号\tvar waitG sync.WaitGroup\tgo gWork(timerCtx, &amp;waitG)\twaitG.Add(1)\twaitG.Wait()&#125;2. 远程过程调用（rpc）\nvalueCtx可以携带一个键值对的context，常用于远程调用传递额外信息如session ID（感觉用处不大）…创建\nkvCtx := context.WithValue(context.Background(),&quot;sessionID&quot;,&quot;9527&quot;)\n获取值,注意如果父contextt也是valueCtx,value查找是只能向父context查找，层层传递低层会覆盖高层（实际上没有覆盖），这也是不推荐用的原因，新手接手项目可能会困惑或者你加一个我加一个也可能会乱……\nvalue := kvCtx.Value(&quot;sessionID&quot;)\n\n原理https://cloud.tencent.com/developer/article/1996581 核心：\n\n非emptyCtx包含一个context接口类型保存父context信息，用一个map保存子context信息\n新开G监听cancel信息（&lt;-c.Done()），当触发cancel时遍历子context，调用子context的cancel，从而引发链式反应，让整个树都cancel\n\n","categories":["golang"],"tags":["golang"]}]